2017 IEEE 19th International Conference on High Performance Computing and Communications; IEEE 15th International Conference on Smart City; IEEE 3rd International Conference on Data Science and Systems

# Analysis and Modeling of the End-to-End I/O Performance on OLCF's Titan Supercomputer

Lipeng Wan, Matthew Wolf, Feiyi Wang, Jong Youl Choi, George Ostrouchov and Scott Klasky Oak Ridge National Laboratory

Oak Ridge, Tennessee 37831 Email: {wanl, wolfmd, fwang2, choij, ostrouchovg, klasky}@ornl.gov

*Abstract*—With the increase of scale and complexity seen in a variety of leadership-class scientific computation and simulation applications, it has become more important to understand their I/O performance characteristics. The user-observed performance is a combination of properties of how the application is using the HPC facility, as well as how others' use of the facility causes variability in the static machine capabilities. Our work leverages statistical analysis of I/O performance data gathered with fine time resolution over a full week from Titan supercomputer. Based on observed properties of the distribution of I/O latencies, we build a three-state hidden Markov model (HMM) to characterize the end-to-end I/O performance on Titan. We parameterize our model using part of the field-gathered I/O performance data and validate it against the rest. The validation results demonstrate that our model can capture the dynamics of end-to-end I/O performance on Titan accurately.

# I. INTRODUCTION

The scale and complexity of high-performance parallel storage facilities have increased significantly during the past decade. As has been observed repeatedly, since these largescale storage systems are shared by many users and applications, a side-effect of this complexity is that it also exacerbates the potential resource contention and load imbalance in the storage systems, which leads to I/O performance variability for end-user applicatons. Such variability is rooted in the confluence of the application's utilization of the interconnect, the nature of the interconnect network design, and the nature of the I/O from the other users' jobs.

This variability in performance is one source of jitter in the OS operation on leadership-class machines. For example, recent studies by Lofstead et al. [1], Liu et al. [2], Luu et al. [3] and Wan et al. [4] demonstrate the impact of such variability and jitter on real, production applications at scale. We observe that the source of this variability involves both intrinsic (e.g. user-controllable choices on I/O) and extrinsic (e.g. other users, system failures [5], etc.) factors. The core research question we seek to address can therefore be simply expressed: How best can we quantify the external, extrinisic factors that effect an application's performance so that it can effectively modify its behavior to reduce its exposure to performance inconsistencies.

Simplistic models for such mitigation are routinely generated based on worst-case analysis that gets hard-coded into the application. For instance, an application developer may notice that the timing on a particular I/O routine might vary over an order of magnitude. In order to make sure that I/O does not exceed 10% of total runtime, therefore, the developer might choose the pessimistic time, and therefore only write data out 1/10th as often as in the more optimistic case. Even if the available I/O bandwidth is high and stable for the machine when the job is running, these simplistic approaches would not be able to capitalize on it.

The work presented here, therefore, is one step towards presenting a more functional and yet easily programmable interface for end users. Scientific end users frequently have complex knowledge about the form and type of data, including conservation laws the data must obey, boundary conditions, and so on. Literal byte-by-byte transfer of data is not always needed; as long as the data conforms to the appropriate conservation laws, etc. and is close enough to the original, the relevant scientific intent can still be achieved [6]. Runtime systems need a dynamic and expressive way of understanding such user quality-of-information priorities along with a good model of system performance if you are going to offer services that do better than the simple, static time slicing. In future work, we are looking at different approaches for the former – How is it best to say I could tolerate a losy compression as long as it is within 95% of correct? How to express the desire to write as often as possible, as long as it is less than 10% of the total runtime, but not less than once an hour? The focus of this work, though, is in the connection between such a runtime and the characterization of the variability of the I/O system that it works on.

Thus, before one can build such a system, it is necessary to have a predictive performance model that has sufficient robustness to allow for adaptation of the user's I/O. This also has to be fast enough so that its results can be used in nearrealtime to make control decisions. Importantly, the model does not need to be cycle accurate; it only needs to provide the information necessary to make a control decision. Based on detailed observations of system behavior on Titan supercomputer, which is DOE's largest HPC facility maintained by Oak Ridge Leadership Computing Facility (OLCF), we have demonstrated that one can construct a hidden Markov model (HMM) that, although missing in some details, is sufficient to make the sorts of decisions our eventual runtime will require.

The contribution of this paper can be summarized as three aspects:

• We present fine-grained I/O measuring tests on a pro-

978-1-5386-2588-0/17 $31.00 © 2017 IEEE DOI 10.1109/HPCC-SmartCity-DSS.2017.1 duction leadership-class storage system (OLCF's Titan supercomputer and its backend file system) and collect time-dependant I/O traces demonstrating I/O performance variability.

- We build a three-state hidden Markov model based on observed characteristics of the time-varying I/O performance traces.
- We demonstrate the effectiveness of leveraging the threestate hidden Markov model to characterize the dynamics of the end-to-end I/O performance in the leadership-class computing environment, with pointers to situations where a more complex model may be needed in future work.

The remainder of this paper is organized as follows. In Section II we introduce some background knowledge about our evaluation and testing platform, OLCF's Titan supercomputer and its center-wide file system Spider II. We describe the methodology of our I/O measurements and do an initial analysis of them in Section III. Based on these results, we next develop our hidden Markov model in Section IV and demonstrate its effectiveness in Section V. In Section VI, we provide a survey of existing studies that concentrate on characterizing and modeling I/O performance in HPC environment. Finally, we conclude with our findings and future work in Section VII.

#### II. BACKGROUND

We conduct our end-to-end I/O measurement on one of the largest leadership-class computing facilities in the world, OLCF's Titan supercomputer and its center-wide file system, Spider II. Herein we provide an overview of Titan and Spider II to facilitate the follow-up discussion.

Titan is a Cray XK7 system with 18,688 compute nodes, and a total system memory of 710 TB. This high capability compute machine is backed by a center-wide parallel file system known as Spider II [7]. Spider II, which is based on the Lustre storage architecture [8], is one of the world's fastest and largest POSIX-complaint parallel file systems. It is designed to serve write-heavy I/O workloads and perform approximately six times faster with three times the capacity of its predecessor, Spider [9]. Figure 1 shows the topology diagram, and in particular, the multi-layered I/O path between Titan and Spider II.

In order to provide connectivity over different networks and communicate between file system clients and servers over these networks, Lustre provides a network abstraction layer called LNET (Lustre Networking). In fact, on the frontend at the compute side of Titan computing facility, there are two different types of nodes: compute and Lustre I/O router nodes. Both types of nodes are part of the Gemini network [10] in 3D torus topology. Each node has a unique network ID (NID) for addressing purposes. According to [11], 440 XK7 service nodes are configured as Lustre LNET routers on Titan. Of these, 432 are used for file I/O and 8 are for metadata communication. Titan I/O routers are connected to the Spider II TOR switches via InfiniBand FDR links, and the Spider II TOR switches enable these I/O routers to reach to the backend storage system. The backend storage system of Titan consists

![](_page_1_Figure_8.png)

Fig. 1: Infrastructure and I/O path between Titan and its backend storage.

of 288 Lustre Object Storage Servers (OSSs) and 2,016 Lustre Object Storage Targets (OSTs), which are divided into two independent file systems, *atlas1* and *atlas2*. Specifically, each TOR switch (36 in total) is connected with a total of 8 OSSs while each OSS is connected to 7 OSTs over direct InfiniBand (IB) FDR links.

In summary, Titan computing facility has complicated largescale I/O subsystems, where multiple hardware and software components are involved along each I/O path between the compute nodes and the storage backend. Since some of these components, such as the routers and switches, are shared by I/O traffic from many different jobs, the I/O congestion and interference, which can cause significant variability or even degradation of I/O performance, might occur more often.

# III. END-TO-END I/O PERFORMANCE MEASUREMENT AND ANALYSIS

In this section, we start by describing our measurement methodology, then present the detailed analysis of performance data collected from Titan.

# *A. Measurement Methodology*

Due to the complexity and scale of the storage systems in HPC environment, I/O path follows complex routes, which involves multiple hardware and software components. More importantly, components such as the routers and switches, are resources shared by many I/O paths. Therefore, I/O congestion and interference are prone to occur, which can cause significant variability or even degradation of I/O performance. On the other hand, the elapsed time between the calling and returning of the I/O function measured at the application level might not reflect the actual delay caused by all the components on the I/O path. For example, if the application calls the POSIX "write" function to write some data, rather than being transmitted to the storage backend immediately, the data might just be cached in the OS kernel or the buffer of those intermediate hardware devices when the "write" function returns. Therefore, in order to have a *stable* and *true* understanding of the performance variability along each I/O path in HPC storage systems, we focus on the *end-to-end* I/O latency and conduct periodic probing and measurement during an one-week time period on Titan supercomputing facility.

*1) Measurement Setup:* Since our study focuses on the endto-end I/O latency, when we design and implement the measuring tests, we have taken three requirements into consideration.

First, we need to be able to control which OST (the object storage target) the data will be written to. This can be achieved by leveraging the *llapi* provided by Lustre file system. We also need to mitigate the caching effect in Lustre file system so that the elapsed time measured at the application level can be treated as a rough estimate of the end-to-end I/O latency. Thus, in our code, we enable the O *DIRECT* option for POSIX I/O to bypass the system buffers and call *fdatasync* function after the POSIX write to force the data to be committed to the storage backend. The end-to-end write latency includes both the time spent on POSIX *write* and the delay caused by *fdatasync*.

Second, in order to study how the end-to-end I/O performance varies over time, our I/O measuring job needs to issue the I/O requests to the OSTs periodically and the time interval between two consecutive I/O requests should be short enough so that more I/O performance dynamics can be captured. For example, in each run of our measurement job on Titan, we reserved 18 compute nodes and launched one MPI process per node. Each of these processes writes 1MB data to a specific OST and then read the same 1MB data back every minute. In an ideal case, we would like to have the measurement job run continuously for one week. In practice though, the scheduling policy of Titan does not allow jobs at this scale to run for very long. For example, our job is allowed to run for at most 1 hour on Titan during each submission. Therefore, in order to conduct continuous measurement for longer period of time, we implement a background process and automatically resubmits the measurement job based on the status of the job queue. Specifically, the daemon process continuously monitors the job queue associated with our account, and resubmit the measurement job immediately once the previous submission has been completed. Although the new submission might not be scheduled to run right after the previous job's completion, the time intervals between two consecutive job runs are usually not very long given the small job size (small jobs usually have less waiting time in the job queue).

Third, we need to carefully select the size of each I/O request as well as the OST each I/O request is sent to. The goal is to minimize the overhead caused by our I/O measurement job. As we have already mentioned, for both write and read request, the size of each request in our measurement is 1MB. The reason we only measure the latency of 1MB I/O request is that the Lustre file system for Titan sets 1MB as the default RPC transfer size. If an I/O request from the application level is larger than 1MB, Lustre will split it into multiple 1MB data chunks and send them to the storage backend through the RPC protocol. In other words, the latency of I/O requests larger than 1MB can be estimated as the sum of multiple 1MBrequests' latency. In our measurement on Titan, we select 18 OSTs from *atlas1* file system based on the system topology so that no two of these OSTs are under the same OSS in Figure 1. This strategy can make sure the I/O requests issued by our measurement job do not interfere each other.

*2) I/O Trace Collection:* In order to obtain accurate timing information, we adopt the similar technique used by [12] to measure the latency of different I/O operations. By leveraging the dynamic library preloading technique, we can intercept each low-level I/O function call and record the elapsed time spent on each function call in a lightweight manner. At the end of each run of the measurement job, the I/O traces of each process are stored in an individual trace file. Since we only focus on several I/O function calls, the size of those trace files are negligible.

# *B. Measurement Results and Analysis*

*1) Characteristics of End-to-End I/O Latency in Leadership-Class HPC Systems:* In leadership-class computing facilities, the I/O subsystem is shared by many scientific simulation and analysis jobs running concurrently, each of which might have different spatial and temporal I/O access patterns. For example, some of these jobs stripe their data across all the OSTs in the system while the others only use a small portion of the OSTs. Additionally, the intensity of I/O operations from different jobs is also different from each other. Therefore, how the I/O performance varies over time and across different OSTs needs to be carefully studied.

Figure 2 shows the histograms of the end-to-end latency of 1MB writes issued to 9 different OSTs in Titan's Spider II Lustre file system. Each row of the set of histograms represents samples from specific OSTs averaged over a week (for the first row) or a specific day (for the rest). From the histograms, we can observe that: 1) On the same day of the week, the distribution of end-to-end I/O latency of different OSTs looks similar to each other, even though we intentionally select the OSTs from different I/O congestion domains (These OSTs belong to different IB switches and OSSs) for our measurement. This observation demonstrates that the data striping strategy adopted by Lustre file system can evenly distribute the I/O traffic to all OSTs most of the time. 2) Even for the same OST, the distribution of end-to-end I/O latency on different days of the week are different. This is because the intensities of the I/O operations from jobs running on different days are usually different.

Now let us look into more details of the end-to-end I/O latency on Titan's Lustre file system. Here we use performance numbers collected from OST-0 as an example. The histogram of the end-to-end latency of 1MB write requests issued to OST-0 on Titan during the entire week is shown in Figure 3. From the figure, we can observe that the distribution of the single OST's end-to-end I/O latency shows some multi-modal characteristics. Specifically, the probability density function of the end-to-end I/O latency given by the kernel density estimation has two local minimas, which divide the values of the end-to-end latency into three sections. We can also observe similar multi-modal characteristics from the performance numbers collected from other OSTs (see Figure 2).

![](_page_3_Figure_0.png)

Fig. 2: Histograms of the end-to-end latency of 1MB write requests issued to 9 different OSTs (the ID of each OST is labeled above each column) in Titan's Spider II Lustre file system during one week (Mar. 6-13, 2017) and on each day of that week. Note that the log-10 scale is used for x-axis.

![](_page_3_Figure_2.png)

Fig. 3: End-to-end latency of a single OST in Titan's Lustre file system. The blue curve illustrates the estimated probability density function given by kernel density estimation, while the two red dash lines indicate the two local minimas.

These observations indicate that the *degree of busyness* of each end-to-end I/O path in HPC systems can be characterized by three performance states: idle, transitional and busy state. In fact, here is an intuitive explanation of the existence of these performance states. On each end-to-end I/O path, the devices (such as routers, switches, and OSSs) which are shared by I/O traffic from different jobs can be simplified as queues that hold the I/O requests from the applications. When those queues are relatively empty, the I/O requests can be forwarded to the storage backend quickly, meaning the I/O path is in the idle state. With the increase of the I/O traffic, those queues are getting saturated and the I/O path enters the transitional state. Finally, when those queues are full and the waiting time of I/O requests increases significantly, the I/O path is in busy state. Moreover, since the waiting time of each queue is random, given the I/O path is in a specific performance state, the latency on that I/O path is a random variable following a probability distribution rather than some deterministic values.

*2) Characteristics of Performance State Transitions on I/O Paths:* If our conjecture about the three performance states on each end-to-end I/O path is true, a more interesting question we should think about is how the I/O performance transits between these three states over time.

Here we still use the performance numbers collected from OST-0 on Titan as an example. As shown Figure 3, though the actual I/O latency distributions of different states overlap each other and the boundaries are not clearly distinguishable, we can still use the two local minimas of the estimated probability density function to roughly estimate the boundaries between different performance states. According to Figure 3, the two local minimas are achieved when the end-to-end I/O latency values are 0.005 seconds and 0.008 seconds. Therefore, we can manually label each data points in our performance measurement results in this way: If the measured end-to-end latency at a specific time is less than 0.005 seconds, we label the state of the I/O path at that time as idle. If it is greater than 0.008 seconds, we label the state at that time as busy. If it falls within the interval between 0.005 and 0.008, we label the state as transitional. Since the timestamp of each latency value was also recorded in our measurement, we can calculate the time between state transitions using the labeled time series latency data and analyze the statistical properties of it.

First, we obtain the time between state transitions using the performance data measured in time periods with different lengths: the first 12 hours, the first 24 hours and the first 72 hours of our measurement. We use five different probability distributions to fit to the time between state transitions during these three time periods. In order to illustrate the fitness of these five distributions, we present the Q-Q plot for each distribution in Figure 4. Specifically, each Q-Q plot compares the quantiles drawn from the measurement data (y-axis) to theoretical quantiles calculated from a particular distribution using parameters estimated by the probability distribution fitting. If the quantiles of the time between state transitions extracted from our measurement data came from the same distribution, the points in the Q-Q plot will approximately lie on the line y = x. As shown in Figure 4(a) and 4(b), in the first 12 hours and 24 hours of our measurement, the exponential distribution fits the time between state transitions best. In other words, this indicates if we treat the transition between the performance states as an event, the occurrence of this event satisfies a Poisson distribution during a time-period less than 24 hours. However, when the time period is greater than 24 hours, this property might not exist anymore. For instance, as shown in Figure 4(c), the exponential distribution does not fit the time between state transitions when the time period increases to 72 hours, which means the transition rates between performance states on different days are different. This is mainly because the intensities of I/O operations from jobs running on different days are significantly different.

Second, we need to validate whether the property of the time between state transitions we illustrated above is temporary or lasting. We obtain the time between state transitions using the performance data measured on each day of the week. Then we again use the exponential distribution to fit each dataset and present the Q-Q plots in Figure 5 to show the fitness. From the fitting results, we can observe that the exponential distribution fits to the time between state transitions well except that on Thursday and Friday. As discussed in more detail in Section III, the fit to an exponential disribution is an important property for our modeling effort. We also did the Kolmogorov-Smirnov test (K-S test) for each dataset to quantify the distance between the empirical distribution function of the sample and the cumulative distribution function of the exponential distribution. The results of K-S test also indicate that the empirical distribution of the time between state transitions is close to exponential distribution, with a somewhat greater divergence on Thursday and Friday. This divergence should not significantly impact our short-range predictive goals, but it does point the way to further future work.

In summary, our analysis of the one-week I/O performance measurement results not only demonstrates the existence of different performance states on each end-to-end I/O path in HPC systems, but also reveals some important statistical properties of transitions between these performance states. In the next section, we are going to introduce how to leverage these findings to build a performance model for each end-toend I/O path in leadership-class computing facilities.

![](_page_4_Figure_3.png)

(a) End-to-end latency of OST-0 sampled during the first 12 hours are used.

![](_page_4_Figure_5.png)

(b) End-to-end latency of OST-0 sampled during the first 24 hours are used.

![](_page_4_Figure_7.png)

(c) End-to-end latency of OST-0 sampled during the first 72 hours are used.

Fig. 4: Q-Q plots for visualizing the fitness of using different distributions to fit to the time between state transitions of OST-0 in Titan's Spider II Lustre file system. The dataset of time between state transitions is generated by using end-to-end latency sampled during time periods with different lengths.

#### IV. MODEL OF END-TO-END I/O PERFORMANCE

The analysis of the end-to-end I/O latency measured on Titan has shown that the time between state transitions might follow exponential distributions during a time period less than 24 hours. Statistically speaking, if the time between the occurrence of an event follows an exponential distribution, the stochastic process has the memoryless property, which is also referred to as *Markov property*. Therefore, we leverage the Markov property revealed by our measurement and analysis to model the end-to-end I/O performance of HPC systems in this section.

# *A. Continuous-Time Hidden Markov Model*

The aforementioned three performance states are artificial definitions, given the dataset characteristics. We can only speculate their existence based on the estimated probability density function of the end-to-end I/O latency we measured. On the other hand, our analysis indeed finds some Markov property from the measurement results. Therefore, we establish a continuous-time hidden Markov model to characterize the end-to-end I/O latency.

As shown in Figure 6, the three performance states are the hidden states of our hidden Markov model. The transitions

![](_page_5_Figure_0.png)

Fig. 5: Q-Q plots for visualizing the fitness of using *exponential* distribution to fit to the time between state transitions of OST-0 in Titan's Spider II Lustre file system on each day of the week.

![](_page_5_Figure_2.png)

Fig. 6: Continuous-time hidden Markov model for end-to-end I/O latency of single OST in leadership-class storage systems.

between these states are determined by the transition rates, which can be represented by a matrix Q, called the *transition rate matrix* or *infinitesimal generator* of the continuous-time Markov process. In our case, Q is a 3 × 3 matrix as follows:

$$Q=\begin{pmatrix}-(\lambda_{01}+\lambda_{02})&\lambda_{01}&\lambda_{02}\\ \lambda_{10}&-(\lambda_{10}+\lambda_{12})&\lambda_{12}\\ \lambda_{20}&\lambda_{21}&-(\lambda_{20}+\lambda_{21})\end{pmatrix}\tag{1}$$

Several important properties of a continuous-time Markov process can be derived using the matrix Q. Specifically, the holding time of state i follows an exponential distribution with rate j λij for i -= j. If a transition occurs on state i, the probability that the Markov process will transit to j as the next state is λij j λij for i -= j. Moreover, the transition matrix of a continuous-time Markov process, P(t), which is a function of time, can be represented as P(t) = eQt.

Figure 6 also illustrates, given the Markov process is in hidden state i at time t (Xt = Si), the observed variable Yt, which is the I/O latency in our case, follows a distribution with Fi(y, θi) as the cumulative distribution function (CDF), where θi represents the parameter set of the CDF. This distribution is also called the *emission probability distribution* of hidden state i. Since the I/O latency is always greater than 0 and its histogram shown in Figure 3 has a long tail, we use the lognormal distribution as the emission probability distribution for all three hidden states in our case.

In summary, we can consider the end-to-end I/O latency we observed in Figure 3 were drawn from a mixture model where the hidden variables (the three performance states in our case), which control the mixture component to be selected for each observation, follows a Markov process rather than independent of each other.

#### *B. Model Parameter Estimation*

The most critical step toward making our model useful in practice is finding a set of parameters for the model so that the it can accurately capture the statistical properties of the observed variable. In our model, the parameters that need to be estimated include the transition rates between different hidden states and the parameters of the emission probability distribution of each hidden state, while the observed variable is the end-to-end I/O latency.

The most commonly used method to estimate the parameters of a statistical model given observations is *maximum likelihood estimation* (MLE). Since this method is simple and efficient, we also adopt it to estimate the parameters of our continuous-time hidden Markov model. First, we need to build the likelihood function for our model. Let us assume we have observed m I/O latency values {yt1 , yt2 ,...,ytm} at m different time points {t1, t2,...,tm}, the likelihood function can be formulated as

$$L=P(y_{t_{1}},y_{t_{2}},\ldots,y_{t_{m}})$$ $$=\sum P(y_{t_{1}},y_{t_{2}},\ldots,y_{t_{m}}|X_{t_{1}},X_{t_{2}},\ldots,X_{t_{m}})\tag{2}$$ $$P(X_{t_{1}},X_{t_{2}},\ldots,X_{t_{m}}),$$

where {Xt1 , Xt2 ,...,Xtm} are random variables representing which hidden state the Markov process is in at time {t1, t2,...,tm}, and the sum is taken over all possible paths of state transitions. Thanks to the Markov property, we can have P(Xti |Xt1 , Xt2 ,...,Xti−1 ) = P(Xti |Xti−1 ). Then with the assumption that the observed I/O latency values are conditionally independent given the values of the hidden states, the likelihood function can be further simplified as

$$L=\sum_{X_{t_{1}}}P(y_{t_{1}}|X_{t_{1}})P(X_{t_{1}})\sum_{X_{t_{2}}}P(y_{t_{2}}|X_{t_{2}})P(X_{t_{2}}|X_{t_{1}})\tag{3}$$ $$\cdots\sum_{X_{t_{m}}}P(y_{t_{m}}|X_{t_{m}})P(X_{t_{m}}|X_{t_{m-1}}),$$

Algorithm 1 EM algorithm for parameter estimation Require: Observed values Y , initial guess of parameters Θ0, accuracy ε 1: Set Θ=Θ ˜ 0; 2: Determine Θ, such that ∂F (Θ,Θ) ˜ ∂Θ = 0; 3: Compute ΔL = log(L(Y |Θ)) − log(L(Y |Θ)) ˜ ; 4: if ΔL>ε then 5: Set Θ=Θ ˜ ; 6: Go to step 2; 7: end if

where P(yti |Sti ) is determined by the emission probability density (the density of log-normal distribution in our case) and P(Xti |Xti−1 ) is the (Xti−1 , Xti ) entry of the transition matrix P(t) evaluated at time t = ti − ti−1.

Second, we need to find the set of parameters that maximize the likelihood function. The representation of the likelihood function given above contains too many details. In order to make our description simple, we use L(Y |Θ) = L(Y,X|Θ)dX to denote the likelihood function, where Y = {yt1 , yt2 ,...,ytm} are the observed values and X are the hidden variables. Since it is too complex to maximize the likelihood function directly, an iterative algorithm called the expectation-maximazation (EM) algorithm is usually used. In order to use the EM algorithm, we need to make an initial assumption on the parameters Θ0. Then we use the expectation value of the log-likelihood to build the following function

$$F(\Theta,\Theta_{0})=E[log(L(Y,X|\Theta))|\Theta_{0}]\tag{4}$$

Now instead of maximizing the likelihood function directly, we can maximize the function F using the EM algorithm iteratively as shown in 1. More details about maximum likelihood estimation and EM algorithm can be found in [13].

# V. MODEL VALIDATION

In order to demonstrate the effectiveness of using the threestate hidden Markov model to characterize the end-to-end I/O performance in Titan, we build a simulator to mimic our parametrized hidden Markov model based on Monte Carlo method. Then we validate our model by comparing the simulation results with the field-gathered performance data.

As described in Section III, we collected performance numbers of each OST continuously for one week. As part of our evaluation, we use the performance numbers collected within a 12 hour window to train the hidden Markov model for each OST, and then we use that parameter set for prediction during the subsequent 12 hours. In particular, we use them to drive a Monte Carlo simulation that can then be compared to the actual measurements. Specifically, the simulation of the Markov process produces a series of state transition events with the timing information attached to each event. Given the Markov process is in a specific state at a specific time, the parametrized emission probability distribution of that state is used to generate the performance number as an observation at that specific time. In the end, our simulation produces a time series in which each data point represents the performance value observed at a specific time.

Now for each OST, we compare the time series of the performance values generated by our model with the actual performance numbers collected during the subsequent 12 hours. Here we still use OST-0 as an example. Validating the models of the other OSTs follows the same steps. As shown in Figure 7, the top sub-figure is the histogram of the write throughput numbers from the I/O traces collected within the second 12 hours on Monday, while the bottom one is the the histogram of the the performance numbers generated by the simulation that was parameterized by the preceding 12 hours. In order to have a fair comparison, we let the simulation generate the same number of performance values as the I/O trace. From the figure, we can observe that the distribution of the performance values generated by simulation appears similar to that calculated from the actual performance data.

![](_page_6_Figure_10.png)

Fig. 7: Histogram of throughput of 1MB write requests obtained from actual I/O traces and simulation respectively

![](_page_6_Figure_12.png)

Fig. 8: Q-Q plots for visualizing the fidelity of our model in characterizing the performance data collected on Monday, Thursday and Sunday

But how close are these two distributions statistically? Again, we adopt Q-Q plots to visualize the similarity between the performance data traces and the simulation results parametrized by a non-overlapping window. In Figure 8, we illustrate three Q-Q plots for measured and simulated data from windows on Monday, Thursday and Sunday respectively. As one can see in Figure 2, our experimental traces show some substantial changes in the nature of the external interference traffic over the course of the week, and these three days allow us to explore how well the restriction to only three states does within the Markov model.

As already shown in Figure 5, the exponential distribution fits to the time between state transitions well on Monday,

7

Tuesday, Wednesday and Saturday, implying strong Markov property on these days, while on Thursday and Friday such property is relatively weak. The Markov property of Sunday data is stronger than that of Thursday and Friday data, but weaker than the other days' data. Now let us look at the Q-Q plots shown in Figure 8. Similarly, our model achieves the best fidelity in characterizing the performance data collected on Monday, and the fidelity in characterizing data collected on Sunday is better than that on Thursday. This result indicates that although our model works well as long as the Markov property holds over the 12 hour window period on most of the days of that week, its fidelity might degrade if the transition rates between different performance states are changing dramatically in relatively short time period (like what happened on Thursday and Friday), since the Markov property requires time-independent transition rates. A future exploration of this data will be to see if updating the model dynamically using smaller collection windows can adequately adapt to the changing state transition rates. Additionally, although the fidelity of the simulation distribution may be less than desirable for purely prediction purposes, its appropriateness as feedback for a control model can also be evaluated as further work.

#### VI. RELATED WORK

In this section, we present a brief literature review on existing efforts to understand and model the I/O performance of scientifc computation and analysis workloads in highperformance computing systems.

In order to understand the performance characteristics of large-scale parallel I/O, existing studies have conducted different kinds of I/O performance measurements and analysis on different HPC systems. For example, the I/O performance of newly deployed leadership-class computing facilities, such as Intrepid, Edison and Titan, are usually extensively measured and studied [14], [15], [11] using the synthetic I/O benchmarks like IOR (Interleaved or Random parallel I/O benchmark) [16] before being put into production. Since the I/O subsystems in high-performance computing facilities are often shared by many users, the I/O congestion and interference are common and might significantly degrade the I/O performance. Thus some other studies, like those presented in [1], [17], [18] [4], focus on measuring and analyzing I/O performance variability in production HPC environments. For developers and users of those scientific applications, they usually only study the I/O behavior and performance of their own applications by analyzing the runtime traces collected from the execution of their application jobs. For example, [19] presented the analysis of two-month application-level I/O traces collected from Intrepid, a 557-teraflop IBM Blue Gene/P system, using Darshan I/O tracing tool [20]. [3] analyzed Darshan traces collected from three different supercomputing facilities during a much longer time period (6 years). Although all these studies provide some valuable insight into the I/O performance characteristics of HPC systems and applications, few of them comes up with models that are generic enough for application developers to understand the I/O performance variabilities in HPC environment.

Due to the limitation of studying the I/O performance through pure measurement, some existing work concentrate on building generic I/O performance models for either the storage systems or the HPC applications. For example, in [21] the authors apply machine learning techniques to building a decision tree based model to predict the I/O performance in HPC environments. In [22], techniques for modeling HPC I/O workloads are proposed, which can be used to generate synthetic I/O workloads to mimic I/O workloads from real HPC applications based on researchers' requirements and make the I/O performance study more flexible. A grammarbased appraoch is proposed in [23], which can predict spatial and temporal I/O patterns. In [24], [25], [26], models are built to study the checkpoint/restart I/O in heterogeneous HPC storage systems. All these models introduce some interesting ideas to characterize the performance or patterns of HPC I/O, but few of them is able to adapt to the I/O variabilities we observed in the HPC systems.

Since running large-scale I/O performance measurements on production supercomputing facilities is not only difficult but also expensive, analyzing and understanding the I/O performance characteristics of HPC systems through simulation is another approach adopted by existing studies. For example, [27] proposes a parallel discrete-event simulation tool named CODES for analyzing performance of exascale storage systems. Built upon CODES, FusionSim is developed to simulate a newly designed parallel file system [28]. Similar simulation tools also include PFSsim [29] and SIMCAN [30], which are two parallel file system simulators developed under the OMNeT++ framework [31]. Although these simulation tools provide more flexibilities in I/O performance analysis, they often require a lot of computational resources and need a long time to produce some useful results.

#### VII. CONCLUSION AND FUTURE WORK

Characterizing the dynamics of I/O performance at high performance computing facilities has been a challenging research problem for many years. This work has become more necessary due to all of the technical changes in the decade, including: the deepening of the storage hierarchies, the increase of system scales (both on-node and the number of nodes), the complex end-to-end I/O paths, and the sharing nature of critical I/O resources without centralized control mechanisms. In this study, we analyzed the I/O performance data we gathered over a full week with a fine time resolution on the Titan supercomputer, which is deployed and managed by the Oak Ridge Leadership Computing Facility (OLCF). The analysis results not only provided us valuable insight into the I/O performance and variability, but it also allowed us to build a three-state hidden Markov model (HMM) which we used to characterize and validate the end-to-end I/O performance of the Titan supercomputer.

We have started to use this model to predict the I/O performance, and our latest results have already showed the same characteristics, which further indicate that our findings in this paper are consistent, and are valid for long-term I/O performance characterization. We will work to collect more data over much longer time periods and refine our model and publish the new findings. Furthermore, we will use our model to understand more complicated I/O control mechanisms, such as dynamic data refactoring, compression, and I/O-aware job scheduling.

#### REFERENCES

- [1] J. Lofstead, F. Zheng, Q. Liu, S. Klasky, R. Oldfield, T. Kordenbrock, K. Schwan, and M. Wolf, "Managing Variability in the IO Performance of Petascale Storage Systems," in *Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis*, ser. SC '10, 2010, pp. 1–12.
- [2] Q. Liu, N. Podhorszki, J. Logan, and S. Klasky, "Runtime I/O Re-Routing+ Throttling on HPC Storage," in *HotStorage*, 2013.
- [3] H. Luu, M. Winslett, W. Gropp, R. Ross, P. Carns, K. Harms, M. Prabhat, S. Byna, and Y. Yao, "A Multiplatform Study of I/O Behavior on Petascale Supercomputers," in *Proceedings of the 24th International Symposium on High-Performance Parallel and Distributed Computing*, ser. HPDC '15, 2015, pp. 33–44.
- [4] L. Wan, M. Wolf, F. Wang, J. Youl Choi, G. Ostrouchov, and S. Klasky, "Comprehensive Measurement and Analysis of the User-Perceived I/O Performance in a Production Leadership-Class Storage System," in *IEEE 37th International Conference on Distributed Computing Systems*, ser. ICDCS '17, 2017, pp. 1022–1031.
- [5] L. Wan, F. Wang, S. Oral, S. S. Vazhkudai, and Q. Cao, "A Report on Simulation-Driven Reliability and Failure Analysis of Large-Scale Storage Systems," Oak Ridge National Laboratory, Tech. Rep. ORNL/TM-2014/421, December 2014.
- [6] S. Klasky, E. Suchyta, M. Ainsworth, Q. Liu, B. Whitney, M. Wolf, J. Youl Choi, I. Foster, M. Kim, J. Logan, K. Mehta, T. Munson, G. Ostrouchov, M. Parashar, N. Podhorszki, D. Pugmire, and L. Wan, "Exacution: Enhancing Scientific Data Management for Exascale," in *IEEE 37th International Conference on Distributed Computing Systems*, ser. ICDCS '17, 2017, pp. 1927–1937.
- [7] S. Oral, D. A. Dillow, D. Fuller, J. Hill, D. Leverman, S. S. Vazhkudai, F. Wang, Y. Kim, J. Rogers, J. Simmons *et al.*, "OLCF's 1 TB/s, Nextgeneration Lustre File System," in *Proceedings of Cray User Group Conference (CUG 2013)*, 2013.
- [8] P. J. Braam *et al.*, "The Lustre Storage Architecture," 2004.
- [9] L. Wan, F. Wang, S. Oral, D. Tiwari, S. S. Vazhkudai, and Q. Cao, "A Practical Approach to Reconciling Availability, Performance, and Capacity in Provisioning Extreme-Scale Storage Systems," in *Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis*, ser. SC '15, 2015, pp. 75:1–75:12.
- [10] R. Alverson, D. Roweth, and L. Kaplan, "The Gemini System Interconnect," in *18th IEEE Symposium on High Performance Interconnects (HOTI '10)*, 2010, pp. 83–87.
- [11] S. Oral, J. Simmons, J. Hill, D. Leverman, F. Wang, M. Ezell, R. Miller, D. Fuller, R. Gunasekaran, Y. Kim, S. Gupta, D. Tiwari, S. S. Vazhkudai, J. H. Rogers, D. Dillow, G. M. Shipman, and A. S. Bland, "Best Practices and Lessons Learned from Deploying and Operating Large-scale Datacentric Parallel File Systems," in *Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis*, ser. SC '14, 2014, pp. 217–228.
- [12] H. Luu, B. Behzad, R. Aydt, and M. Winslett, "A Multi-Level Approach for Understanding I/O Activity in HPC Applications," in *2013 IEEE International Conference on Cluster Computing*, ser. CLUSTER '13, 2013, pp. 1–5.
- [13] M. R. Gupta and Y. Chen, "Theory and Use of the EM Algorithm," *Foundations and Trends in Signal Processing*, vol. 4, no. 3, pp. 223– 296, 2011.
- [14] S. Lang, P. Carns, R. Latham, R. Ross, K. Harms, and W. Allcock, "I/O Performance Challenges at Leadership Scale," in *Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis*, ser. SC '09, 2009, pp. 40:1–40:12.
- [15] Z. Zhao, D. Petesch, D. Knaak, and T. Declerck, "I/O Performance on Cray XC30," in *Proceedings of the Cray User Group Conference*, ser. CUG '14, 2014.

- [16] LLNL, "The Interleaved Or Random (IOR) Benchmark," https://github. com/chaos/ior, 2016.
- [17] B. Xie, J. Chase, D. Dillow, O. Drokin, S. Klasky, S. Oral, and N. Podhorszki, "Characterizing Output Bottlenecks in a Supercomputer," in *Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis*, ser. SC '12, 2012, pp. 8:1–8:11.
- [18] B. Dong, S. Byna, and K. Wu, "Heavy-tailed Distribution of Parallel I/O System Response Time," in *Proceedings of the 10th Parallel Data Storage Workshop*, ser. PDSW '15, 2015, pp. 37–42.
- [19] P. Carns, K. Harms, W. Allcock, C. Bacon, S. Lang, R. Latham, and R. Ross, "Understanding and Improving Computational Science Storage Access through Continuous Characterization," in *IEEE 27th Symposium on Mass Storage Systems and Technologies*, ser. MSST '11, 2011, pp. 1–14.
- [20] P. H. Carns, R. Latham, R. B. Ross, K. Iskra, S. Lang, and K. Riley, "24/7 Characterization of Petascale I/O Workloads," in *Proceedings of the First Workshop on Interfaces and Abstractions for Scientific Data Storage*, 2009.
- [21] J. Kunkel, M. Zimmer, and E. Betke, "Predicting Performance of Noncontiguous I/O with Machine Learning," in *30th ISC High Performance Conference*, 2015, pp. 257–273.
- [22] S. Snyder, P. Carns, R. Latham, M. Mubarak, R. Ross, C. Carothers, B. Behzad, H. V. T. Luu, S. Byna, and Prabhat, "Techniques for Modeling Large-scale HPC I/O Workloads," in *Proceedings of the 6th International Workshop on Performance Modeling, Benchmarking, and Simulation of High Performance Computing Systems*, ser. PMBS '15, 2015, pp. 5:1–5:11.
- [23] M. Dorier, S. Ibrahim, G. Antoniu, and R. Ross, "Omnisc'IO: A Grammar-based Approach to Spatial and Temporal I/O Patterns Prediction," in *Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis*, ser. SC '14, 2014, pp. 623–634.
- [24] L. Wan, Z. Lu, Q. Cao, F. Wang, S. Oral, and B. Settlemyer, "SSD-Optimized Workload Placement with Adaptive Learning and Classification in HPC Environments," in *30st International Conference on Massive Storage Systems and Technology*, ser. MSST '14, 2014.
- [25] L. Wan, "Achieving High Reliability and Efficiency in Maintaining Large-Scale Storage Systems through Optimal Resource Provisioning and Data Placement," Ph.D. dissertation, University of Tennessee, Knoxville, 2016.
- [26] L. Wan, Q. Cao, F. Wang, and S. Oral, "Optimizing Checkpoint Data Placement with Guaranteed Burst Buffer Endurance in Large-Scale Hierarchical Storage Systems," *Journal of Parallel and Distributed Computing*, vol. 100, pp. 16–29, 2017.
- [27] N. Liu, C. Carothers, J. Cope, P. Carns, R. Ross, A. Crume, and C. Maltzahn, "Modeling a Leadership-scale Storage System," in *Proceedings of the 9th International Conference on Parallel Processing and Applied Mathematics - Volume Part I*, ser. PPAM '11, 2011, pp. 10–19.
- [28] D. Zhao, N. Liu, D. Kimpe, R. Ross, X.-H. Sun, and I. Raicu, "Towards Exploring Data-Intensive Scientific Applications at Extreme Scales through Systems and Simulations," *IEEE Transactions on Parallel and Distributed Systems*, vol. 27, no. 6, pp. 1824–1837, 2016.
- [29] Y. Liu, R. Figueiredo, D. Clavijo, Y. Xu, and M. Zhao, "Towards Simulation of Parallel File System Scheduling Algorithms with PFSsim," in *Proceedings of the 7th IEEE International Workshop on Storage Network Architecture and Parallel I/O*, ser. SNAPI '11, 2011.
- [30] A. Nu´nez, J. Fern ˜ andez, J. D. Garcia, F. Garcia, and J. Carretero, ´ "New Techniques for Simulating High Performance MPI Applications on Large Storage Networks," *The Journal of Supercomputing*, vol. 51, no. 1, pp. 40–57, 2010.
- [31] A. Varga and R. Hornig, "An Overview of the OMNeT++ Simulation Environment," in *Proceedings of the 1st International Conference on Simulation Tools and Techniques for Communications, Networks and Systems & Workshops*, ser. Simutools '08, 2008, pp. 60:1–60:10.

