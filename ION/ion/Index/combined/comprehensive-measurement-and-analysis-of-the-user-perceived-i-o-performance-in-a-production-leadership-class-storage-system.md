# Comprehensive Measurement and Analysis of the User-Perceived I/O Performance in a Production Leadership-Class Storage System

Lipeng Wan, Matthew Wolf, Feiyi Wang, Jong Youl Choi, George Ostrouchov and Scott Klasky Oak Ridge National Laboratory Oak Ridge, Tennessee 37831

Email: {wanl, wolfmd, fwang2, choij, ostrouchovg, klasky}@ornl.gov

*Abstract*—With the increase of the scale and intensity of the parallel I/O workloads generated by those scientific applications running on high-performance computing facilities, understanding the I/O dynamics, especially the root cause of the I/O performance variability and degradation in HPC environment, have become extremely critical to the HPC community. In this paper, we run extensive I/O measuring tests on a production leadershipclass storage system to capture the performance variabilities of large-scale parallel I/O. Analyzing these results and its statistic correlation revealed some valuable insights into the characteristics of the storage system and the root cause of I/O performance variability. Further, we leverage these findings and propose an I/O middleware design refactoring which can improve the performance of the parallel I/O by optimizing the data striping and placement. Our preliminary evaluation results demonstrate the proposed approach can reduce the average per-process write latency by at least 80% and the maximum per-process write latency by at least 20%.

#### I. INTRODUCTION

The scale and complexity of high-performance parallel storage facilities have increased significantly during the past decade. Since these large-scale storage systems are usually shared by many users and absorbing huge amount of data generated by a wide variety of applications, a side-effect of this growing complexity is that it also exacerbates the potential resource contention and load imbalance in the storage systems, which leads to non-negligible, user-perceived I/O performance variability.

It has been known that the efficiency of large-scale parallel computation jobs is sensitive to the I/O performance variability. For example, the analysis results presented by recent studies, such as [1], [2], [3], etc., reveal that the I/O performance those large-scale parallel scientific applications achieved in production runs suffers from the I/O variabilities of the storage systems. Specifically, since the performance of the parallel I/O is often determined by the slowest process (all the other processes are blocked and cannot resume the computation until the slowest process completes the I/O), more variabilities on the I/O latency lead to more wasted computation time during the application's execution, thereby more wasted energy and money.

From user's perspective, the I/O variabilities increase the difficulties in estimating and requesting computation resources as well. For example, when the users submit their scientific jobs to the supercomputers, they need to specify how much execution time is required to complete their jobs and let the job scheduler allocate the computation resources based on their requirements. The total execution time of a scientific application usually consists of two parts, the time spent on the computation and that spent on the I/O. Compared to the computation time, which is often deterministic and easy to estimate, the time spent on the I/O operations is much more inconstant and time-dependent. Due to the inconstancy of the I/O latency, the execution time allocated to the job might be used up and the job has to be terminated before the completion of the computation. Without further precaution, the existing computation results will be lost because of such nondeterministic job termination. Actually, in practice, the users have to rely on some form of defensive programming techniques, such as "checkpointing", to periodically export their execution state and intermediate results to a persistent storage, so that the terminated job can be resumed without rolling back to the very beginning of the computation. Similarly, "checkpointing" incurs extra overhead in terms of both CPU time and I/O bandwidth.

Furthermore, the uncertainty brought by the I/O variabilities makes it difficult for the users of the scientific applications to arrange and optimize their workflows in an efficient way. For example, during the execution of some scientific simulation program such as XGC [4], some of the intermediate simulation results are periodically written to the storage system. Users can analyze or visualize such intermediate results during the simulation by reading the data back to memory. Due to the uncertainty of the I/O latency, it is difficult for the users to determine how much intermediate data should be written and how often the online data analysis or visualization should be launched, since the overhead will increase significantly if they are launched at the time when the I/O latency is high.

On the other hand, although many existing studies that focus on the performance analysis of parallel I/O have given some interesting and insightful results, the understanding of the I/O dynamics, especially the root cause of the I/O performance variability and degradation in the large-scale HPC storage systems, is still far from thorough and complete. Therefore, we conduct a comprehensive measurement and analysis of the user-perceived I/O performance in a production leadershipclass storage system, and summarize all our findings in this paper. The main purpose of our study presented by this paper is trying to identify the causal relationship between the characteristics of the storage system and the I/O performance the parallel applications running on that system achieves. More specifically, our study helps us answer multiple important questions about the I/O performance in HPC storage environment, including but not limited to: Why are the ideal I/O performance numbers of single OST hard to achieve? Why is the system caching critical to the I/O performance? Why are I/O requests with some specific sizes achieve better performance than the others? Why does the I/O variability show some strong spatial patterns? etc. Based on our answers to these questions, we propose and evaluate some preliminary I/O middleware designs, which can leverage our findings to refactor the parallel I/O workloads and improve their performance during runtime. The contribution of this paper can be summarized as three aspects:

- We run extensive I/O measuring tests on a production leadership-class storage system and collect huge amount of I/O traces which capture abundant performance dynamics of large-scale parallel I/O.
- We thoroughly analyze the results of our I/O performance measurement, which provide some valuable insights into the characteristics of the storage system and the I/O performance variability. To the best of our knowledge, some of our findings are presented for the first time.
- We introduce how to leverage some of our findings to refactor the parallel I/O from middleware design point of view. The preliminary evaluation results demonstrated the effectiveness of proposed I/O refactoring method.

The remainder of this paper is organized as follows. In section II we provide a survey of existing studies that concentrate on the I/O performance variability issues in HPC environment. We also introduce some background knowledge about our evaluation and test platform, OLCF Titan supercomputer and its center-wide file system Spider II the in section III. We introduce the methodology of our I/O performance measurement in section IV and analyze all the measurement results in section V. Based on our analysis results, we propose and evaluate some preliminary I/O middleware designs in VI. Finally, we conclude our findings and future work in section VII.

## II. RELATED WORK

In this section, we present a brief review on existing work to depicit how the I/O performance variability issue in HPC environment has been studied.

First of all, in order to study the performance variability of the large-scale parallel I/O, many existing work focus on I/O trace collection from production storage systems. In [5], the Darshan I/O tracing tool is presented, which is designed to accurately capture the I/O behavior of large-scale scientific applications. Such tool enables both researchers and applications developers gain more insight into the parallel I/O access patterns at extreme scale, so that they can better utilize the storage systems and improve the I/O performance of the HPC applications. With the help of Darshan, several detailed studies on parallel I/O performance of HPC storage systems have been published. For example, [6] presented the analysis of two-month application-level I/O traces collected from Intrepid, a 557-teraflop IBM Blue Gene/P system, using Darshan. In [3], Darshan traces collected from three different supercomputing facilities during a much longer time period (6 years) are analyzed. Since Darshan aims to collect traces with minimal overhead, it only records summary I/O statistics of each job. However, during the execution of each job, thousands of I/O requests could be issued and each of them might get different performance numbers. Therefore, the measurement results obtained by using Darshan are coarse-grained, and at times may not be enough for a comprehensive understanding of the I/O performance dynamics in HPC storage systems.

Second, besides using tools like Darshan to collect the I/O traces from real HPC applications during production run, the system designers and administrators generally benchmark the I/O performance of the HPC systems with synthetic I/O benchmarks before putting a system into production. For example, the Interleaved or Random (IOR) parallel I/O benchmark [7] is commonly used to test the I/O performance of newly deployed leadership-class computing facilities, such as Intrepid [8], Edison [9], Titan [10], etc. However, since such tests are often run without other background I/O traffic, the measurement results from these tests often cannot capture the performance variability caused by I/O contention. There are two solutions to overcome the deficiency of the pre-production testings. One is using synthetic I/O benchmarks to measure the I/O performance during storage systems' production run, like those presented in [1], [11], [12]. The other one is using vendorprovided tools to collect low-level I/O traces. For example, [13] analyzes the traces collected from two production HPC storage clusters at the backend RAID controller using tools provided by the device manufacturer. All of these studies demonstrate varying degrees of I/O performance variability in the HPC storage systems, but few of them tries to identify the root cause of the performance variability or degradation from a systematic point of view. This is why we consider our study as a complement to the existing work, since we not only conduct the I/O performance measurement and analysis, but also connect the patterns we observed from our measurement results to the inherent design of the storage system.

Since running large-scale I/O performance measurements on production supercomputing facilities is not only difficult but also expensive, some researchers study the performance of parallel I/O in HPC storage systems through simulation. For example, [14] proposes a parallel discrete-event simulation tool named CODES for analyzing performance of exascale storage systems. Built upon CODES, FusionSim is developed to simulate a newly designed parallel file system [15]. Similar simulation tools also include PFSsim [16] and SIMCAN [17], which are two parallel file system simulators developed under the OMNeT++ framework [18]. Although these simulation tools provide more flexibilities in I/O performance analysis, the I/O traces collected from the production storage systems,

![](_page_2_Figure_0.png)

Fig. 1. Infrastructure and I/O path between Titan and its backend storage.

such as the fine-grained I/O traces presented in this paper, are still critical to drive the simulation and validate the simulation results.

In summary, since the HPC storage systems are always shared by many different applications and accessed in parallel, the I/O performance perceived by each application might be affected by many factors which are still unknown to the HPC community during runtime. Our study presented by this paper is a valuable complement to the existing studies and can provide more insight for the HPC community to help both system administrators and application developers better undnerstand the I/O dynamics of the storage systems and inspire them to come up with new approaches to make the usage of the storage systems more efficent.

## III. BACKGROUND

Our primary evaluation and test platform is OLCF Titan supercomputer and its center-wide file system Spider II. Herein we provide an overview to facilitate an understanding and follow-up discussion. Titan is a Cray XK7 system with 18,688 compute nodes, and 710 TB of total system memory. The high capability compute machine is backed by a center-wide parallel file system known as Spider II [19]. Spider II, which is based on the Lustre technology [20], is one of the worlds fastest and largest POSIX-complaint parallel file systems. It is designed to serve write-heavy I/O workloads. Figure 1 shows the topology diagram, and in particular, the multi-layered data path.

In order to provide connectivity over different networks and communicate between file system clients and servers over these networks, Lustre provides a network abstraction layer called LNET (Lustre Networking). Specifically, on the frontend at the compute side of Titan computing facility, there are two different types of nodes: compute and Lustre I/O router nodes. Both types of nodes are part of the Gemini network [21] in 3D torus topology. Each node has a unique network ID (NID) for addressing purposes. 440 XK7 service nodes are configured as Lustre LNET routers on Titan. Of these, 432 are used for file I/O and 8 are for metadata communication. Titan I/O routers are connected to the Spider II TOR switches via InfiniBand FDR links. Note that the Spider II TOR switches enable these I/O routers to reach to the back-end storage system (OSSes and OSTs).

According to [19] and [10], on the back-end storage side, Spider II has 20,160 Near-Line SAS disks organized in RAID 6 arrays. Each of these RAID arrays act as a Lustre Object Storage Target (OST). An OST is the target device where the Lustre parallel file system does file I/O (read or write) at the object layer. The OSTs are connected to the Lustre Object Storage Servers (OSSes) over direct InfiniBand (IB) FDR links; a patched version of Lustre 2.4.3 is running on the I/O servers. The storage system is split into two distinct, nonoverlapping sections, and each is formatted as a separate name space (atlas1 and atlas2) to increase reliability, availability, and overall meta data performance. Each file system has 144 OSSs and 1,008 OSTs. Each OSS is connected to a 36-port IB FDR top-of-the-rack (TOR) switch and two DDN controllers, for reliability. Each TOR switch (36 in total) is connected with a total of 8 OSSes. Each switch also connects to two 108 port aggregation switches. The aggregation switches provide connectivity for the Lustre meta data and management servers.

#### IV. MEASUREMENT METHODOLOGY

The goal of this measurement-driven study is to better understand the dynamics of the user-perceived I/O performance in a production leadership-class storage system. Due to the complexity of the system architecture and the unpredictability of the background workloads in the production environment, the I/O measurement methodology needs to be carefully designed. The remainder of this section introduces the details of our measurement methodology.

## *A. I/O Measurement Setup*

In order to be able to tune the configuration of our I/O performance measurement in a flexible manner, we implement our measurement code based on ADIOS I/O library [22]. By calling different transport methods provided by ADIOS with different parameter settings, our code can measure the userperceived I/O performance under different scenarios. There are two scenarios that our measurement mainly concentrates on: 1) the performance of single OST and 2) the performance of a large number of OSTs under large-scale parallel I/O workloads.

For evaluating the first scenario, we conduct two different tests. The first test is randomly picking one OST from the 1,008 OSTs in atlas1 file system and issuing write requests from a single compute node with different sizes to that OST respectively. The second test is using multiple compute nodes to issue the I/O requests with the same size to the same OST concurrently. We have randomly launched both of these two measurements 20 times during one week period to capture the performance dynamics.

For evaluating the second scenario, in each test, we reserved 1,008 cores on Titan and launched one MPI process per core. By using the ADIOS Lustre transport method which internally calls the *llapi* provided by Lustre file system, we establish an one-on-one mapping between the processes and OSTs, so that the process with rank 0 is mapped to OST 0, that with rank 1 is mapped to OST 1, ..., etc. Each of these processes first writes a specific size of data to the OST paired with it, and then reads the data back from that OST. Performance of 10 different I/O sizes are measured in each iteration. In order to capture the I/O performance dynamics, we ran such performance measurement job on Titan roughly every two hours during one week period.

## *B. I/O Trace Collection*

Since the ADIOS library wraps low-level POSIX I/O function calls with its transport methods, in order to obtain accurate timing information, we adopt the technique used by [23] to measure the latency of those I/O operations. Basically, by leveraging the dynamic library preloading, we can intercept each low-level I/O function call and record the elapsed time spent on each function call in a lightweight manner. In each run of the measurement, the I/O traces of each process are stored in an individual trace file. Since we only focus on several I/O function calls, the size of those trace files are negligible.

#### V. MEASUREMENT RESULTS AND ANALYSIS

In Lustre file system, the large files are usually striped and stored on different OSTs across the system to achieve high throughput. Those data chunks are bulk transferred between the Lustre clients and the OSTs through a large-scale and highspeed network. In this section, we present and analyze the measurement results of the user-perceived I/O performance under two scenarios: 1) only issuing I/O requests to a single OST and 2) issuing I/O requests to multiple OSTs in parallel.

## *A. User-Perceived Performance of I/O Issued to Single OST*

The purpose of conducting the measurement on single OST is to explore the potential maximum user-perceived I/O performance each OST can achieve in a production environment.

*1) Performance of issuing single I/O request to single OST:* The first measurement we conduct is issuing I/O requests with different sizes to a single OST and collecting the performance statistics for each request. Specifically, we have randomly launched 20 times of this measurement on Spider II storage system during one week. In each measurement, we randomly pick one OST from the 1,008 OSTs in atlas1 file system, and issue write requests with different sizes to that OST respectively. Although we measure the performance of write requests with sizes ranging from 4KB to 1GB, we do not present the results of requests less than 1MB due to the space limit, since the Lustre file system uses 1MB RPC for internal data transmission by default and the I/O requests will not be able to saturate the bandwidth until they are larger than 1MB.

![](_page_3_Figure_9.png)

Fig. 2. User-perceived throughput of issuing a single write request to a single OST (without "fsync")

Another thing worth noting is that we do not exclude the effect of system caching from the measurement results shown in Figure 2 (we do not call the "fsync" function after each write) as we focus on the user-perceived performance. In our later measurement, we evaluate the I/O performance when caching effect is excluded by calling the "fsync" function (see Figure 4).

As illustrated in Figure 2, for issuing a single write request to a single OST, if the request size is within the range from 1MB to 1GB, the user-perceived write throughput might be more than 600MB/s.

Key Insight: Performance of single OST under single write request could be much higher than the performance applications usually achieve during the production runs. For issuing a single write request to a single OST, the best user-perceived write throughput can be achieved in the production Spider II storage system is more than 600MB/s, which can be treated as an ideal performance number for Spider II. However, due to the I/O interference and contention, such number is rarely observed for production runs and we will demonstrate this in our following measurements.

*2) Impact of concurrent access to single OST:* The second measurement we conduct is issuing multiple I/O requests to the same OST simultaneously to evaluate how the concurrent access to a single OST affects the user-perceived I/O performance. In order to eliminate the interference at the compute node level, in our measurement, we only launch one Lustre object storage client (OSC) on each compute node and each of them issues one write request with the same size to the same OST.

As shown in Figure 3, if the size of the write request is larger than 64MB, when we increase the number of OSCs issuing the write requests concurrently, the average user-perceived write throughput per OSC drops accordingly due to the interference as we expect. Surprisingly, however, for the write request with size ranging from 1MB to 64MB, even we increase the number of concurrent write requests to 64, the average throughput per OSC almost remains the same as that achieved by only issuing

![](_page_4_Figure_0.png)

Fig. 3. Average user-perceived per-request throughput when issuing multiple write requests to a single OST (without "fsync")

a single write request.

Key Insight: For specific write request sizes, concurrent access to single OST does not necessarily lead to performance degradation. The counterintuitive observation on write requests with size ranging from 1MB to 64MB implies that the Lustre file system reserves resources in a per-client manner to reduce the interference between concurrent I/O requests. In fact, based on Lustre's design documents, when configuring the LNET routers, a parameter named *peer buffer credits* is used to control the number of messages buffered for each OSC and such parameter is set as 64 in Spider II. Therefore, our conjecture about the root cause of this observation is: The 64MB write request from each OSC is divided into 64 RPC messages which just saturate the buffer of LNET routers. Since the LNET router mantains a buffer with such size for each OSC, even the number of concurrent requests increases, they do not interference with each other much. However, if the size of each write request is larger than 64MB, the buffer on the LNET router reserved for each OSC cannot hold all the messages generated by each write request. Therefore, the data transmission latency increases, leading to performance degradation.

*3) Impact of system caching on user-perceived performance:* In the third measurement, we evaluate how the system caching affects the user-perceived I/O performance. Basically, in our source code developed for the performance measurement, we call "fsync" function right after the "write" function which notifies the file system to flush the data buffered in all levels of system cache to the storage devices. Then when we calculate the I/O throughput for each measurement case shown in Figure 4, we include the time spent on data flushing.

As shown in Figure 4, if we call the "fsync" function to exclude the effect of system caching, the time spent on data flushing dominates the I/O lantency which degrades the average user-perceived per-request throughput significantly. Moreover, the benefit of writing data smaller than 64MB per request, which we have observed in Figure 3, does not exist

![](_page_4_Figure_6.png)

Fig. 4. Average user-perceived per-request throughput when issuing multiple write requests to single OST (with "fsync")

anymore.

Key Insight: System caching is critical to maintaining high I/O throughput in large-scale parallel storage systems. Without system caching, significant degradation on userperceived I/O performance occurs. This is also why application developers do not use "fsync" in their code very often except when the users have extremely strict requirement on data persistence.

## *B. User-Perceived Performance of Large-Scale Parallel I/O*

Lustre file system is designed for large-scale parallel I/O generated by HPC applications, therefore, we conduct intensive experiments to measure the user-perceived performance of Spider II storage system under large-scale parallel I/O. Specifically, in each measurement, we used 1,008 cores on Titan and launch one MPI process on each core. Using the *llapi* provided by Lustre file system, we form an one-onone mapping between the processes and OSTs. Basically, the process with rank 0 is mapped to OST 0, that with rank 1 is mapped to OST 1, ..., etc. Each of these processes first writes a specific size of data to the OST paired with it, and then reads the data back from that OST. Both the write and read performance statistics are recorded. We ran such performance measurement job on Titan roughly every two hours (since the execution of each job on Titan is scheduled by the job scheduler, we cannot guarantee the time interval between two consective measurements is constant) during one week and collected results of 84 times (around 12 times per day) I/O performance measurement in total.

*1) Overview of the measurement results on full-scale parallel I/O during one week:* We first present an overview of the one-week performance measurement results under the fullscale parallel I/O (issuing parallel I/O requests to all OSTs in atlas 1 file system). In Figure 5, we illustrate the average user-perceived I/O throughput values collected from all 1,008 OSTs during one week. From the figure, we can observe that the 4MB I/O requests achieve the best average per-OST throughput and for requests with size larger than 4MB, the

![](_page_5_Figure_0.png)

Fig. 5. Comparison between per-OST write and read throughput under fullscale parallel I/O during one week

per-OST throughput decreases with the increase of the request size. Another interesting observation is the read performance is much worse than the write performance in Spider II. For example, when the 4MB I/O requests are issued, the average user-perceived per-OST write throughput is almost 80% higher than the read throughput.

Key Insight: Large-scale parallel I/O requests generate interference along the I/O path. Under the full-scale parallel I/O, the per-OST throughput drops significantly when the size of the I/O requests is larger than 64MB. Since only one I/O request is issued to each OST, different from the previous measurement where multiple I/O requests are forwarded to the same OST through almost identical paths, the I/O paths for different requests are different in this measurement. However, some devices, such as the LNET routers, IB switches, OSSs, etc., could still be shared by different I/O paths. Therefore, our conjecture is the parallel I/O requests with size larger than 64MB cause resource contention at these devices along the I/O path and degrade the performance.

Key Insight: The write operations outperform the read operations on Spider II. The gap between the read and write performance observed in our measurement on a production leadership-class storage system is not suprising, as different from the read function call which cannot be returned until the data is transmitted all the way from the storage devices to the application, the write function call can be returned to the application before the data is actually committed to the storage devices with the help of system caching, meaning the user-perceived write performance could be much higher than the read performance. Since reading the entire dataset with full precision could take much longer time than we expect, it is necessary to apply data reduction techniques to future high-performance computing and storage systems. Actually, if the entire dataset can be stored as different data chunks with different precision levels and the applications can selectively read the data chunks based on their precision requirements, the efficiency of the storage system will increase significantly.

![](_page_5_Figure_5.png)

Fig. 6. Histogram of user-perceived per-OST write throughput under fullscale parallel I/O at different time during one day (Nov. 14, 2016, Monday)

*2) Variabilities of user-perceived I/O performance:* Next we analyze the variabilities of the user-perceived performance under large-scale parallel I/O, including the performance difference among OSTs and how the I/O performance varies with time. Due to the space limit, we only present the write performance here. The variabilities of the user-perceived read performance shows similar patterns.

In Figure 6, we illustrate the histogram of the user-perceived per-OST write throughput collected from all 1,008 OSTs in atlas 1 at different time of a day. Specifically, each row in this figure shows the performance distributions among OSTs under different write request sizes at a specific time, while each column shows how the performance distributions among OSTs vary across time during a day. First, from the figure, we can observe that there is significant performance difference among OSTs at each measurement time. For example, when we wrote 1MB data to each OST at 7:25am on Nov. 14, 2016, the maximum write throughput achieved among all the OSTs was 507.86MB/s, while the minimum one was only 24.98MB/s. Second, we can observe that although the distribution of the per-OST write throughput varies with time, there is still some stable patterns exist. For example, when the size of the write request is 1MB or 4MB, the distribution of the userperceived per-OST write throughput shows some multimodal characteristics. When the I/O request size approaches 64MB, the performance distribution becomes stable. If the request size continuously increases to 256MB or 1GB, the multimodal characteristics appear again and a considerable portion of OSTs' throughput decreased to less than 200MB/s..

Key Insight: Imbalanced I/O traffic distribution among OSTs aggravates the performance variability. The significant performance difference among OSTs observed at each measurement time indicates that the I/O traffic are not evenly distributed in the parallel storage system. At any given time, some of the OSTs are more heavily used than the others. The imbalanced I/O traffic increases the performance variabilities which has significant affect on the I/O performance of the large-scale parallel computing jobs. Especially, when a job is writing a checkpoint, no matter when all the other processes complete the checkpoint write, they usually cannot resume the computation until the slowest process finishes the I/O. Therefore, the default I/O placement strategy provided by Lustre which places the data stripes in a round-robin fashion among OSTs is suboptimal. A load-aware data placement strategy is needed during runtime which can distribute the data in a more balanced way (direct more I/O traffic to relatively idle OSTs, etc.).

Key Insight: The performance distribution among OSTs shows some multimodal characteristics. The multimodal characteristics observed in the distribution of the userperceived per-OST write throughput suggest that the I/O traffic from other jobs running on the system is competing the bandwidth on some OSTs with the I/O from our measurement job. Specifically, when the size of the write requests from our measurement job is relatively small (1MB or 4MB), the I/O performance of our measurement job on some OSTs is affected by the I/O traffic from some other large-scale jobs, which is why we observe multiple peaks with different bandwidth values in the histogram. When the size of the write requests approaches 64MB, the I/O from our measurement job dominates the bandwidth and the I/O performance becomes relatively stable. When the request size is relatively large (256MB or 1024MB), the write requests from our measurement job start interfering each other, leading to significant performance degradation, which is reflected by the histograms.

Compared to the box plot which only shows the summary statistics, the violin plot can show the distribution shape of the data based on the kernel density estimation, which is particularly useful for visualizing data with multimodal distributions. Specifically, in the violin plot, wider sections of the violin plot represent a higher probability that members of the population will take on the given value, while the skinnier sections represent a lower probability. Therefore we adopt violin plot to visualize the distribution of the userperceived per-OST write throughput on each day of the week in Figure 7. First, from the figure, we can also observe the multimodal characteristics in the per-OST performance distribution, especially when the size of the write requests is

![](_page_6_Figure_4.png)

Fig. 7. Violin plot of user-perceived per-OST write throughput under fullscale parallel I/O on different days during one week (Nov. 14–20, 2016)

relatively small (1MB, 4MB, or 16MB). Second, for the small request sizes, the performance distribution on Friday, Saturday and Sunday show different pattern compared to that on the other four weekdays. Specifically, more OSTs shows good performance numbers during Friday to Sunday than that on the other four weekdays, meaning the storage system is relatively idle on Friday and the weekend. Moreover, during Monday to Thursday, the performance numbers of OSTs spread out across a wide range more evenly, which means the I/O workloads from other running jobs hit a large number of OSTs with different intensity on the weekdays.

*3) Impact of system topology on parallel I/O performance:* According to the system architecture of Spider II, the I/O traffic issued to multiple OSTs might share same devices along the I/O path, which means the performance achieved on each OST is not independent to each other. Therefore, by analyzing the correlation between performance of all OSTs can help us understand how the system topology impact the I/O performance. Since we launched our measurement job 84 times during one week, for each OST, we obtained 84 user-perceived performance values. If we define the random variable Xi and Xj to represent the user-perceived performance of the i-th and j-th OST, we can use those 84 observed performance values to calculate the sample correlation coefficient as follows to estimate the population Pearson correlation between the userperceived performance of the i-th and j-th OST:

$$r_{x_{i}x_{j}}=\frac{\sum_{k=1}^{n}(x_{i}^{k}-\hat{x_{i}})(x_{j}^{k}-\hat{x_{j}})}{(n-1)s_{x_{i}}s_{x_{j}}}\tag{1}$$ $$=\frac{\sum_{k=1}^{n}(x_{i}^{k}-\hat{x_{i}})(x_{j}^{k}-\hat{x_{j}})}{\sqrt{\sum_{k=1}^{n}(x_{i}^{k}-\hat{x_{i}})^{2}\sum_{k=1}^{n}(x_{j}^{k}-\hat{x_{j}})^{2}}},$$

where xˆi and xˆj are the sample means of Xi and Xj , n is 84 in our case.

For each pair of OSTs, we can calculate the correlation coeefficient using the above formula and finally form the correlation matrices of the user-perceived performance of all

![](_page_7_Figure_0.png)

Fig. 8. Pearson correlation between user-perceived performance of all OST pairs

1,008 OSTs under write requests with different sizes. We visualize those correlation matrics in Figure 8, where the more shadowy the element is, the higher correlation coeefficient it has. Since we only want to focus on those OST pairs with moderate and strong correlation, according to the suggestion given by [24], we exclude the elements whose values are less 0.4 from the correlation matrix shown in each sub-figure of Figure 8.

From these correlation matrices, we can observe that the user-perceived per-OST performance shows some strong spatial patterns. For example, when the size of the write request is relatively small (1MB–16MB), the correlation matrix shows some stripe patterns. Or more specifically, as shown in Figure 8(a), 8(b), 8(c), some rows (or columns) of the correlation matrix have darker color, meaning the OSTs represented by those rows have moderate or strong correlation with more OSTs than the other OSTs do. Also, the rows with darker color are evenly distributed in the correlation matrix. When the size of the write request increases to 64MB, as shown in Figure 8(d), the previous stripe patterns fade away and the correlation among OSTs becomes weak. However, as shown in Figure 8(e) and 8(f), when the size of each write request continuously increases to 256MB and 1GB, a new "chess board" pattern shows up. Basically, in the correlation matrix the elements with higher correlation coeefficient values group into many squares with different sizes, which further form multiple stripes parallel to the diagonal of the correlation matrix.

Key Insight: The performance of large-scale parallel I/O on Spider II shows strong spatial patterns. Our conjuecture on the root cause of these interesting patterns shown in the correlation matrix is the tree-like topology of the storage system. In the storage system, multiple OSTs usually share some I/O devices along the I/O path, including OSSs, IB switches, LNET routers, etc. If the I/O contention happens on these devices, the performance of the OSTs sharing these devices might be affected simultaneously. This is why these OSTS have relatively strong correlation with each other. Since the OSTs sharing the same device are not necessarily numbered in a consecutive manner, we can observe such stripe patterns in the correlation matrix. Moreover, parallel I/O with different per-request sizes generates different patterns in the correlation matrix. Actually, when the size of the write request is large (1GB for example), the I/O requests issued by our measurement job generate some congestions along the I/O path at the IB switch level, etc. Since 56 different OSTs share one IB switch, we can clearly observe those 56×56 squares around the diagonal of the correlation matrix. All these patterns we observed indicate that when issuing large-scale parallel I/O to the storage system, the I/O traffic placement needs to be carefully crafted to mitigate the interferances.

## VI. DESIGN IMPACT AND ANALYSIS

Our measurement and analysis results reveal some interesting I/O characteristics of the Spider II storage system. In this section, we introduce how to leverage some of our findings to refactor the parallel I/O from middleware design point of view. For this initial study, we only focus on the parallel writes o improve the I/O performance in Spider II. We also present some preliminary evaluation results to demonstrate the

![](_page_8_Figure_0.png)

Fig. 9. An example of refactoring and balancing large parallel writes on Spider II

effectiveness of our I/O refactoring method and the value of our performance study.

## *A. Motivation*

According to our measurement and analysis results, due to the per-client caching mechanism inherent in Lustre file system, if the size of data written per process is less than or equal to 64MB, each process can still acheive relatively high user-perceived write throughput even when multiple processes write the data to the same OSTs simultaneously (as shown in Figure 3). On the other hand, if the size of the data written per process is greater than 64MB, even one process only writes data to one OST, the throughput degrades significantly when a large number of processes write the data concurrently (as shown in Figure 5 and 6). Therefore, in order to improve the write performance of the large-scale parallel jobs, especially the performance of large writes, we need to refactor the placement of the I/O traffic to leverage the I/O characteristics of the storage systems.

More specifically, since the 64MB-per-process writes achieve relatively high throughput with less variance on Spider II storage system, our basic idea of refactoring the large-scale parallel writes is to split the data chunks larger than 64MB into that of size 64MB, while at the same time reorganize the placement of those data chunks among OSTs to balance the I/O traffic. We can achieve this goal through two different approaches: 1) We can set the data stripe size and stripe count to satisfy our requirement using the *llapi* provided by Lustre file system. 2) We explicitly split the large data chunk into multiple chunks of size 64MB and create multiple threads so that each thread writes only 64MB to one OST. We illustrate an example in Figure 9.

As shown in Figure 9, assuming 1,008 compute nodes are allocated to our job, the original I/O workload is launching one process on each of these compute nodes and establishing

![](_page_8_Figure_7.png)

Fig. 10. Write latency per process before and after the I/O refactoring

an one-on-one mapping between the processes and OSTs so that the process with rank 0 writes 256MB to OST 0, that with rank 1 writes 256MB to OST 1, ..., etc. In order to leverage the caching benefits, we refactor the original I/O and split the 256MB-write into four 64MB-writes. As shown in the Figure, each of these 64MB data chunks is delivered to a different OST and the following strategy is used to balance the write traffic to each OST: If we use dij to denote the j-th data chunk (64MB) from compute node i, then di0 is sent to the OST i, di1 is sent to OST (i + 1), ..., etc. Once i + j > 1007, data chunk dij is sent to OST (i + j − 1008).

## *B. Evaluation*

As we have mentioned above, there are two approaches to refactor the large parallel write workload, one is using the *llapi* and the other is explicitly spliting the data chunk. Next we evaluate both of them and analyze which one achieves better performance on Spider II storage system.

In our evaluation, for each run of the measurement job, we write same amount of data using both the original approach and the two I/O refactoring approaches we have mentioned above respectively. We launch our measurement job 10 times randomly during 3 days. As shown in Figure 10 (left), compared to the original write workload, both *llapi*based I/O refactoring and the I/O refactoring through explicit data striping improve the write performance in terms of the average per-process write latency. In fact, the performance improvement of using explicit data striping is more significant than that of using *llapi*-based I/O refactoring. Furthermore, since the performance of the parallel I/O is often determined by the slowest process (all the other processes cannot resume the computation until the slowest process completes the I/O), we also present the maximum latency among all processes for each case. As shown in Figure 10 (right), *llapi*-based I/O refactoring is not better (or even worse) than the original approach, while using explicit data striping achieces lower maximum write latency in all 10 experiments. Therefore, the I/O refactoring based on the explicit data striping has more potential to improve the performance in practice.

## VII. CONCLUSION AND FUTURE WORK

The I/O performance variability has huge impact on the efficiency of those large-scale scientific applications. In this paper, we conducted extensive I/O performance tests on a production leadership-class storage system. Our measurement and analysis results revealed several valuable insights into the characteristics of the storage system and the I/O performance variability, some of which have not been presented by existing studies. By leveraging our these findings and insights, we proposed a I/O middleware design optimization to improve the performance of the parallel I/O by refactoring the data striping and placement. The preliminary evaluation demonstrates the effectiveness of proposed refactoring design. In summary, we studied I/O performance, in particular, the all important userperceived performance through extensive I/O measurement and analysis on a production system. It also proposed new techniques to optimize the efficiency of the parallel I/O and storage systems.

In our future work, we plan to integrate proposed techniques into those widely-used HPC I/O middlewares, such as ADIOS [22]. Besides leveraging the system caching benefits, we can also refactor the data placement based on the spatial patterns observed in our measurement results to mitigate the I/O interference. Moreover, we plan to integrate statistical models into the middleware layer to predict the I/O performance during runtime, so that the adaptive I/O refactoring can be possible.

#### VIII. ACKNOWLEDGEMENT

This material is based upon work supported by the U.S. Department of Energy, Office of Science, Office of Advanced Scientific Computing Research, Program Manager Dr. Lucy Nowell, under Award Number ERKJ311. Also, this research used resources of the Oak Ridge Leadership Computing Facility, which is a DOE Office of Science User Facility.

## REFERENCES

- [1] J. Lofstead, F. Zheng, Q. Liu, S. Klasky, R. Oldfield, T. Kordenbrock, K. Schwan, and M. Wolf, "Managing Variability in the IO Performance of Petascale Storage Systems," in *Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis*, ser. SC '10, 2010, pp. 1–12.
- [2] Q. Liu, N. Podhorszki, J. Logan, and S. Klasky, "Runtime I/O Rerouting + Throttling on HPC Storage," in *Proceedings of the 5th USENIX Conference on Hot Topics in Storage and File Systems*, ser. HotStorage '13, 2013.
- [3] H. Luu, M. Winslett, W. Gropp, R. Ross, P. Carns, K. Harms, M. Prabhat, S. Byna, and Y. Yao, "A Multiplatform Study of I/O Behavior on Petascale Supercomputers," in *Proceedings of the 24th International Symposium on High-Performance Parallel and Distributed Computing*, ser. HPDC '15, 2015, pp. 33–44.
- [4] OLCF, "Multiphysics Magnetic Fusion Reactor Simulator, from Hot Core to Cold Wall," https://www.olcf.ornl.gov/caar/xgc/, 2016.
- [5] P. H. Carns, R. Latham, R. B. Ross, K. Iskra, S. Lang, and K. Riley, "24/7 Characterization of Petascale I/O Workloads," in *Proceedings of the First Workshop on Interfaces and Abstractions for Scientific Data Storage*, 2009.
- [6] P. Carns, K. Harms, W. Allcock, C. Bacon, S. Lang, R. Latham, and R. Ross, "Understanding and Improving Computational Science Storage Access through Continuous Characterization," in *IEEE 27th Symposium on Mass Storage Systems and Technologies*, ser. MSST '11, 2011, pp. 1–14.

- [7] LLNL, "The Interleaved Or Random (IOR) Benchmark," https://github.com/chaos/ior, 2016.
- [8] S. Lang, P. Carns, R. Latham, R. Ross, K. Harms, and W. Allcock, "I/O Performance Challenges at Leadership Scale," in *Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis*, ser. SC '09, 2009, pp. 40:1–40:12.
- [9] Z. Zhao, D. Petesch, D. Knaak, and T. Declerck, "I/O Performance on Cray XC30," in *Proceedings of the Cray User Group Conference*, ser. CUG '14, 2014.
- [10] S. Oral, J. Simmons, J. Hill, D. Leverman, F. Wang, M. Ezell, R. Miller, D. Fuller, R. Gunasekaran, Y. Kim, S. Gupta, D. Tiwari, S. S. Vazhkudai, J. H. Rogers, D. Dillow, G. M. Shipman, and A. S. Bland, "Best Practices and Lessons Learned from Deploying and Operating Large-scale Datacentric Parallel File Systems," in *Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis*, ser. SC '14, 2014, pp. 217–228.
- [11] B. Xie, J. Chase, D. Dillow, O. Drokin, S. Klasky, S. Oral, and N. Podhorszki, "Characterizing Output Bottlenecks in a Supercomputer," in *Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis*, ser. SC '12, 2012, pp. 8:1–8:11.
- [12] B. Dong, S. Byna, and K. Wu, "Heavy-tailed Distribution of Parallel I/O System Response Time," in *Proceedings of the 10th Parallel Data Storage Workshop*, ser. PDSW '15, 2015, pp. 37–42.
- [13] R. Gunasekaran, S. Oral, J. Hill, R. Miller, F. Wang, and D. Leverman, "Comparative I/O Workload Characterization of Two Leadership Class Storage Clusters," in *Proceedings of the 10th Parallel Data Storage Workshop*, ser. PDSW '15, 2015, pp. 31–36.
- [14] N. Liu, C. Carothers, J. Cope, P. Carns, R. Ross, A. Crume, and C. Maltzahn, "Modeling a Leadership-scale Storage System," in *Proceedings of the 9th International Conference on Parallel Processing and Applied Mathematics - Volume Part I*, ser. PPAM '11, 2011, pp. 10–19.
- [15] D. Zhao, N. Liu, D. Kimpe, R. Ross, X.-H. Sun, and I. Raicu, "Towards Exploring Data-Intensive Scientific Applications at Extreme Scales through Systems and Simulations," *IEEE Transactions on Parallel and Distributed Systems*, vol. 27, no. 6, pp. 1824–1837, 2016.
- [16] Y. Liu, R. Figueiredo, D. Clavijo, Y. Xu, and M. Zhao, "Towards Simulation of Parallel File System Scheduling Algorithms with PFSsim," in *Proceedings of the 7th IEEE International Workshop on Storage Network Architecture and Parallel I/O*, ser. SNAPI '11, 2011.
- [17] A. Nu´nez, J. Fern ˜ andez, J. D. Garcia, F. Garcia, and J. Carretero, ´ "New Techniques for Simulating High Performance MPI Applications on Large Storage Networks," *The Journal of Supercomputing*, vol. 51, no. 1, pp. 40–57, 2010.
- [18] A. Varga and R. Hornig, "An Overview of the OMNeT++ Simulation Environment," in *Proceedings of the 1st International Conference on Simulation Tools and Techniques for Communications, Networks and Systems & Workshops*, ser. Simutools '08, 2008, pp. 60:1–60:10.
- [19] S. Oral, D. A. Dillow, D. Fuller, J. Hill, D. Leverman, S. S. Vazhkudai, F. Wang, Y. Kim, J. Rogers, J. Simmons *et al.*, "OLCF's 1 TB/s, Nextgeneration Lustre File System," in *Proceedings of Cray User Group Conference (CUG 2013)*, 2013.
- [20] P. J. Braam *et al.*, "The Lustre Storage Architecture," 2004.
- [21] R. Alverson, D. Roweth, and L. Kaplan, "The Gemini System Interconnect," in *18th IEEE Symposium on High Performance Interconnects (HOTI '10)*, 2010, pp. 83–87.
- [22] OLCF, "The Adaptable IO System (ADIOS)," https://www.olcf.ornl.gov/center-projects/adios/, 2016.
- [23] H. Luu, B. Behzad, R. Aydt, and M. Winslett, "A Multi-Level Approach for Understanding I/O Activity in HPC Applications," in *Proceedings of the IEEE International Conference on Cluster Computing*, ser. CLUS-TER '13, 2013.
- [24] J. D. Evans, *Straightforward Statistics for the Behavioral Sciences*. Pacific Grove : Brooks/Cole Pub. Co., 1996.

